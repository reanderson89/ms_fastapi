name: Tag-Build-Deploy v0

#
# This is experimental
#

on:
  push:
    # branches-ignore:
    #   - test*
    branches:
      - test-*

  workflow_dispatch:
    inputs:
      tag:
        description: "Deploy existing Docker tag?"
        required: true
        default: "latest"
      environment:
        description: "To which environment?"
        type: choice
        default: "dev"
        options:
          - dev
          - staging
          - prod

env:
  SWARM_YAML: "docker-milestones-api-swarm.yml"
  MILESTONES_DOCKER_REPO: "blueboardinc/milestones_api"

jobs:
  tag:
    name: Tag
    runs-on: ubuntu-latest
    if: ${{ github.event_name != 'workflow_dispatch' && ( contains(github.event.head_commit.message, 'major') || contains(github.event.head_commit.message, 'minor') || contains(github.event.head_commit.message, 'foo') ) }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.head_ref }}
          fetch-depth: 0
          persist-credentials: false # this must be false to use the PAT in the push below

      - name: Dump GitHub context (Debugging)
        run: echo '${{ toJSON(github) }}'

      - name: Setup Git Client with PAT for BlueboardBot
        run: |
          # user.name/user.email comes from the last commit
          git config --global user.name '$(git log -n 1 --pretty=format:%an)'
          git config --global user.email  '$(git log -n 1 --pretty=format:%ae)'

          # reconfigure Git client to use the PAT
          git remote remove origin
          git remote add origin https://${{ secrets.BLUEBOARD_BOT_PAT }}@github.com/blueboard/${{ github.event.repository.name }}.git

      - name: Get the Current Version and Bump Level (from Commit Message or PR Subject)
        id: get-version
        env:
          MESSAGE: ${{ github.event.head_commit.message }}
        run: |
          # fetch the most recent tag
          git fetch origin --tags
          git tag --list --sort=creatordate > tags

          # the cut is to strip off the SHA, or everything past the dash
          tail -1 tags

          VERSION=$( tail -1 tags | cut -d '-' -f 1 )

          echo "The VERSION is $VERSION"

          # We started with v0.8.2-21c4777, now VERSION is just 0.8.2
          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT

          # if the words 'major', 'minor' or 'patch' are in the PR subject or commit message
          # then set LEVEL to that

          export MAJOR=$( echo $MESSAGE | tr '\n' ' ' | sed -n -E 's/^.*(major).*$/\1/ip' )
          if [[ ! -z ${MAJOR} ]]; then
            echo "LEVEL=major" >> $GITHUB_OUTPUT
          fi

          export MINOR=$( echo $MESSAGE | tr '\n' ' ' | sed -n -E 's/^.*(minor).*$/\1/ip' )
          if [[ ! -z ${MINOR} ]]; then
            echo "LEVEL=minor" >> $GITHUB_OUTPUT
          fi

          # TODO replce foo with patch here!!!
          export PATCH=$( echo $MESSAGE | tr '\n' ' ' | sed -n -E 's/^.*(foo).*$/\1/ip' )
          if [[ ! -z ${PATCH} ]]; then
            echo "LEVEL=patch" >> $GITHUB_OUTPUT
          fi

      - name: Get the Next Version
        id: sem-ver
        uses: "WyriHaximus/github-action-next-semvers@v1"
        with:
          version: ${{ steps.get-version.outputs.VERSION }}

      - name: Select the Next Version to Use
        id: new-version
        if: ${{ steps.sem-ver.outputs.major != '' }}
        run: |
          # github-action-next-semvers actually calculates all of the various next semver permutations, so we
          # have to decide which one to use based on the commit message in the step above
          if [ '${{ steps.get-version.outputs.LEVEL }}' == 'major' ]; then
            echo 'NEW_VERSION=${{ steps.sem-ver.outputs.major }}' >> $GITHUB_OUTPUT
          elif [ '${{ steps.get-version.outputs.LEVEL }}' == 'minor' ]; then
            echo 'NEW_VERSION=${{ steps.sem-ver.outputs.minor }}' >> $GITHUB_OUTPUT
          elif [ '${{ steps.get-version.outputs.LEVEL }}' == 'patch' ]; then
            echo 'NEW_VERSION=${{ steps.sem-ver.outputs.patch }}' >> $GITHUB_OUTPUT
          fi

      - name: Echo Version Level (Debugging)
        run: |
          echo 'VERSION: ${{ steps.get-version.outputs.VERSION }} (current)'
          echo 'LEVEL: ${{ steps.get-version.outputs.LEVEL }}'
          echo 'NEW_VERSION: ${{ steps.new-version.outputs.NEW_VERSION }} (next)'

      - name: Git Tag the New Version
        if: ${{ steps.new-version.outputs.NEW_VERSION != '' }}
        run: |
          echo 'Updating version tag from ${{ steps.get-version.outputs.VERSION }} to v${{ steps.new-version.outputs.NEW_VERSION }}'

          # reconstruct the full tag, e.g. v5.5.3-39a1b0b
          export SHA=$(git rev-parse --short HEAD)

          # adds 'v' prefix
          export FULL_TAG="v${{ steps.new-version.outputs.NEW_VERSION }}-${SHA}"

          # BLUEBOARD_BOT_PAT is an organization secret for the BlueboardBot account on GitHub
          # The default token that is automatically made available to GitHub actions does not
          # have permission to push tags -- so we have to use a PAT here
          git tag ${FULL_TAG}
          git push https://${{ secrets.BLUEBOARD_BOT_PAT }}@github.com/blueboard/${{ github.event.repository.name }}.git --tags

          # Store the tag in the Git environment for use in the deploy step later
          echo "TAG=$FULL_TAG" >> $GITHUB_OUTPUT

      - name: Set the Environment (Temporary)
        run: |
          echo "Environment is dev"
          echo "ENVIRONMENT=dev" >> $GITHUB_ENV

    outputs:
      environment: ${{ env.ENVIRONMENT }}
      tag: ${{ env.FULL_TAG }}

  build:
    name: Build
    needs:
      - tag
    runs-on: ubuntu-latest
    steps:
      - name: Debugging
        run: |
          echo "Environment:  ${{ needs.tag.outputs.environment }}"
          echo "Tag:  ${{ needs.tag.outputs.tag }}"

      - name: Check out the repo
        uses: actions/checkout@v4
        with:
          submodules: recursive
          # BURP_PAT is a Personal Access Token for the BlueboardBot user that has permissions to read from the BURP repoistory
          # which allows this service to checkout the submodule
          token: ${{ secrets.BURP_PAT }}

      - name: Log in to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN_RW }}

      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.MILESTONES_DOCKER_REPO }}

      - name: Build, tag and push Docker image
        uses: docker/build-push-action@v4
        with:
          context: .
          file: Docker/Dockerfile.milestones_api_swarm
          push: true
          cache-from: type=registry,ref=blueboardinc/milestones_api:latest
          cache-to: type=inline
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}

  deploy:
    name: Deploy
    runs-on: ubuntu-latest
    needs:
      - build
    env:
      # dev/latest are simply sane defaults for these env vars, in the case of workflow_dispatch trigger,
      # the actual values will be set in a step just below
      TAG: ${{ needs.tag.outputs.tag != '' && needs.tag.outputs.tag || 'latest' }}
      ENVIRONMENT: ${{ needs.tag.outputs.environment != '' && needs.tag.outputs.environment || 'dev' }}
    if: |
      always() && ( needs.build.result == 'success' || needs.build.result == 'skipped')
    steps:
      - name: Dump GitHub context (Debugging)
        run: echo '${{ toJSON(github) }}'

      - name: Use Tag and Environment from workflow_dispatch
        if: ${{ github.event_name == 'workflow_dispatch' }}
        run: |
          echo "Using the tag from workflow_dispatch: ${{ github.event.inputs.tag }}"
          echo "TAG=${{ github.event.inputs.tag }}" >> $GITHUB_ENV

          echo "Using the environment from workflow_dispatch: ${{ github.event.inputs.environment }}"
          echo "ENVIRONMENT=${{ github.event.inputs.environment }}" >> $GITHUB_ENV

      - name: Debugging
        run:
          echo 'Deploy ${{ env.TAG }} to ${{ env.ENVIRONMENT }}'

      - name: Use the Docker Swarm Template from dev branch
        uses: actions/checkout@v4
        with:
          ref: dev

      - name: Checkout Shared GitHub Actions
        uses: actions/checkout@v4
        with:
          repository: blueboard/github_actions
          token: ${{ secrets.BLUEBOARD_BOT_PAT }}
          path: .github/actions

      - name: Install and configure Open VPN for ${{ env.ENVIRONMENT }}
        uses: ./.github/actions/setup-open-vpn
        timeout-minutes: 1
        with:
          vpn_ca_crt_b64: ${{ env.ENVIRONMENT == 'prod' && secrets.PROD_VPN_CA_CRT_B64 || secrets.DEV_VPN_CA_CRT_B64 }}
          vpn_cert_crt_b64: ${{ env.ENVIRONMENT == 'prod' && secrets.PROD_VPN_CERT_CRT_B64 || secrets.DEV_VPN_CERT_CRT_B64 }}
          vpn_tls_key_b64: ${{ env.ENVIRONMENT == 'prod' && secrets.PROD_VPN_TLS_KEY_B64 || secrets.DEV_VPN_TLS_KEY_B64 }}
          username: ${{ env.ENVIRONMENT == 'prod' && secrets.PROD_VPN_SECRET_USERNAME || secrets.DEV_VPN_SECRET_USERNAME }}
          password: ${{ env.ENVIRONMENT == 'prod' && secrets.PROD_VPN_SECRET_PASSWORD || secrets.DEV_VPN_SECRET_PASSWORD }}
          vpn_cert_key_b64: ${{ env.ENVIRONMENT == 'prod' && secrets.PROD_VPN_CERT_KEY_B64 || secrets.DEV_VPN_CERT_KEY_B64 }}
          auth: ${{ env.ENVIRONMENT == 'prod' && 'SHA384' || 'SHA256' }}
          ssh_key_b64: ${{ env.ENVIRONMENT == 'prod' && secrets.PROD_SSH_KEY_B64 || secrets.DEV_SSH_KEY_B64 }}
          config: ${{ env.ENVIRONMENT == 'prod' && '.github/vpn/config-prod.ovpn' || '.github/vpn/config.ovpn' }}
          ping_host: ${{ env.ENVIRONMENT == 'prod' && secrets.PROD_LEADER || env.ENVIRONMENT == 'staging' && secrets.STAGING_LEADER || secrets.DEV_LEADER }}

      - name: Export all GitHub Secrets as Environment Variables
        env:
          SECRETS: ${{ toJson(secrets) }}
        run: |
          # the purpose of this step is to export all GitHub secrets as regular
          # env vars so that we can use envsubst in a subsequent step
          # Note: jq adds double quotes around the value, so we must use sed to
          # re-wrap the values with single quotes, but still allowing for double
          # quotes in the env var itself, i.e. so that we end up with this:
          #
          # foo='foobar'
          # bar='barfoo'
          # foobar='bar"foo"foo'
          #
          echo $SECRETS | jq --raw-output '. | to_entries[] | .key + "=" + (.value | tojson)' | \
            sed "s/\=\"/\=\'/" | \
            sed "s/\"$/'/" | \
            sed "s/\"$/'/" >> $GITHUB_ENV
          unset SECRETS

      - name: Create the Docker Swarm Configuration
        env:
          ENV: ${{ env.ENVIRONMENT }}
          IMAGE_TAG: ${{ env.TAG }}
          REPLICAS: ${{ vars.REPLICAS || 1 }}
        run: |
          # append the tag to form a fully qualified Docker tag
          export IMAGE_TAG="${{ env.MILESTONES_DOCKER_REPO }}:${IMAGE_TAG}"

          # do the env substitution and fix any issues with single quotes (more details in the Rails API)
          mv ${SWARM_YAML} ${SWARM_YAML}.orig && envsubst < ${SWARM_YAML}.orig > ${SWARM_YAML}
          # TODO deal with single quotes
          # sed -i "s/''\([^\s]*\)''/'\1\'/g" ${SWARM_YAML}

      - name: Timestamp the Docker Swarm Configuration
        uses: ./.github/actions/stamp-swarm-config
        with:
          file: ${SWARM_YAML}

      - name: Copy Docker Swarm Configuration & Recycle Containers ♻️
        uses: ./.github/actions/update-docker-swarm
        timeout-minutes: 1
        with:
          hosts: ${{ env.ENVIRONMENT == 'prod' && secrets.PROD_HOSTS || env.ENVIRONMENT == 'staging' && secrets.STAGING_HOSTS || secrets.DEV_HOSTS }}
          leader: ${{ env.ENVIRONMENT == 'prod' && secrets.PROD_LEADER || env.ENVIRONMENT == 'staging' && secrets.STAGING_LEADER || secrets.DEV_LEADER }}
          yaml_file: ${{ env.SWARM_YAML }}
          dockerhub_username: ${{ secrets.DOCKERHUB_USERNAME }}
          dockerhub_password: ${{ secrets.DOCKERHUB_TOKEN_RO }}
          app: 'milestones_api'

      - name: Stop the VPN
        if: always()
        run: |
          sudo chmod 444 vpn.log
          cat vpn.log
          sudo killall openvpn