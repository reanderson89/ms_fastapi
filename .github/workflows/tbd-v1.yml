name: Tag, Build & Deploy v1 (AWS)

on:
  push:
    tags-ignore:
      - '**'
    branches:
      - dev
      - main

  workflow_dispatch:
    inputs:
      tag:
        description: "Deploy existing Docker tag?"
        required: true
        default: "latest"
      environment:
        description: "To which environment?"
        type: choice
        default: "dev"
        options:
          - chaos
          - dev
          - staging

env:
  SWARM_YAML: "docker-milestones-api-swarm.yml"
  DOCKER_REPO: "blueboardinc/milestones_api"
  DEBUG: "false" # set to true for a little more output

jobs:
  tag:
    name: Tag
    runs-on: ubuntu-latest
    if: ${{ github.event_name != 'workflow_dispatch' && ( contains(github.event.head_commit.message, 'major') || contains(github.event.head_commit.message, 'minor') || contains(github.event.head_commit.message, 'patch') ) }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.head_ref }}
          fetch-depth: 0
          persist-credentials: false # this must be false to use the PAT in the push below

      - name: Checkout Blueboard's Shared GitHub Actions üîß
        uses: actions/checkout@v4
        with:
          repository: blueboard/github_actions
          token: ${{ secrets.BLUEBOARD_BOT_PAT }}
          path: .github/actions

      - name: Dump GitHub context (Debugging)
        if: env.DEBUG == 'true'
        run: |
          echo '${{ toJSON(github) }}'

      - name: Check for Patch Keyword
        id: patch
        if: contains(github.event.head_commit.message, 'patch')
        run: |
          echo "level=patch" >> $GITHUB_OUTPUT

      - name: Check for Minor Keyword
        id: minor
        if: contains(github.event.head_commit.message, 'minor')
        run: |
          echo "level=minor" >> $GITHUB_OUTPUT

      - name: Check for Major Keyword
        id: major
        if: contains(github.event.head_commit.message, 'major')
        run: |
          echo "level=major" >> $GITHUB_OUTPUT

      - name: Get Next Version
        id: get-next-version
        uses: ./.github/actions/get-versions
        with:
          level: ${{ steps.major.outputs.level || steps.minor.outputs.level || steps.patch.outputs.level }}
          token: ${{ secrets.BLUEBOARD_BOT_PAT }}
          branch: ${{ github.ref_name }}

      - name: Dump get-next-version.outputs (Debugging)
        if: env.DEBUG == 'true'
        run: |
          echo '${{ toJSON(steps.get-next-version.outputs) }}'

    outputs:
      environment: ${{ steps.get-next-version.outputs.environment }}
      tag: ${{ steps.get-next-version.outputs.tag }}

  build:
    name: Build
    needs:
      - tag
    runs-on: ubuntu-latest
    steps:
      - name: Echo Environment and Tag (Debugging)
        if: env.DEBUG == 'true'
        run: |
          echo "Environment:  ${{ needs.tag.outputs.environment }}"
          echo "Tag:  ${{ needs.tag.outputs.tag }}"

      - name: Check out the repo
        uses: actions/checkout@v4
        with:
          submodules: recursive
          # BURP_PAT is a Personal Access Token for the BlueboardBot user that has permissions to read from the BURP repoistory
          # which allows this service to checkout the submodule
          token: ${{ secrets.BURP_PAT }}

      - name: Setup Docker buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN_RW }}

      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.DOCKER_REPO }}

      - name: Build, tag and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: Docker/Dockerfile.milestones_api_swarm
          push: true
          cache-from: type=gha
          cache-to: type=gha,mode=max
          tags: |
            ${{ env.DOCKER_REPO }}:latest
            ${{ env.DOCKER_REPO }}:${{ needs.tag.outputs.tag }}
          labels: ${{ steps.meta.outputs.labels }}

  # the purpose of this pre-deploy job is simply to setup any variables needed for the deploy
  # job, as variables like environment and tag come from two different sources if this was invoked
  # via a commit or a workflow_dispatch event
  # the if always() here allows the GHA to run this job regardless of how the GHA was initially triggered
  pre-deploy:
    name: Pre-Deploy
    runs-on: ubuntu-latest
    if: |
      always() && ( needs.tag.result == 'success' || needs.tag.result == 'skipped' ) && ( needs.build.result == 'success' || needs.build.result == 'skipped' )
    needs:
      - tag
      - build
    steps:
      - name: Use Environment and Tag from the tag job
        if: ${{ github.event_name != 'workflow_dispatch' && needs.tag.outputs.tag != '' }}
        run: |
          echo "tag job environment: ${{ needs.tag.outputs.environment }}"
          echo "tag job tag: ${{ needs.tag.outputs.tag }}"

      - name: Use Environment and Tag from workflow_dispatch
        if: ${{ github.event_name == 'workflow_dispatch' }}
        run: |
          echo "workflow_dispatch environment: ${{ github.event.inputs.environment }}"
          echo "workflow_dispatch tag: ${{ github.event.inputs.tag }}"

    outputs:
      environment: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.environment || needs.tag.outputs.environment }}
      tag: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.tag || needs.tag.outputs.tag }}

  deploy:
    name: Deploy ${{ needs.pre-deploy.outputs.tag}} to ${{ needs.pre-deploy.outputs.environment }}
    runs-on: ubuntu-latest
    if: |
      always() && ( needs.pre-deploy.outputs.tag != '' && needs.pre-deploy.outputs.environment != '' )
    needs:
      - build
      - pre-deploy
    environment: ${{ needs.pre-deploy.outputs.environment }}
    env:
      TAG: ${{ needs.pre-deploy.outputs.tag != '' && needs.pre-deploy.outputs.tag || 'latest' }}
      ENVIRONMENT: ${{ needs.pre-deploy.outputs.environment != '' && needs.pre-deploy.outputs.environment || 'dev' }}
    steps:
      - name: Dump GitHub context (Debugging)
        if: env.DEBUG == 'true'
        run: |
          echo '${{ toJSON(github) }}'

      - name: Use the Docker Swarm Template (always from the dev branch üéóÔ∏è)
        if: github.event_name == 'workflow_dispatch' || needs.build.result == 'success'
        uses: actions/checkout@v4
        with:
          ref: dev

      - name: Checkout Blueboard's Shared GitHub Actions üîß
        if: github.event_name == 'workflow_dispatch' || needs.build.result == 'success'
        uses: actions/checkout@v4
        with:
          repository: blueboard/github_actions
          token: ${{ secrets.BLUEBOARD_BOT_PAT }}
          path: .github/actions

      - name: Export all GitHub Secrets as Environment Variables
        if: github.event_name == 'workflow_dispatch' || needs.build.result == 'success'
        env:
          SECRETS: ${{ toJson(secrets) }}
        run: |
          # the purpose of this step is to export all GitHub secrets as regular
          # env vars so that we can use envsubst in a subsequent step
          # Note: jq adds double quotes around the value, so we must use sed to
          # re-wrap the values with single quotes, but still allowing for double
          # quotes in the env var itself, i.e. so that we end up with this:
          #
          # foo='foobar'
          # bar='barfoo'
          # foobar='bar"foo"foo'
          #
          echo $SECRETS | jq --raw-output '. | to_entries[] | .key + "=" + (.value | tojson)' | \
            sed "s/\=\"/\=\'/" | \
            sed "s/\"$/'/" | \
            sed "s/\"$/'/" >> $GITHUB_ENV
          unset SECRETS

      - name: Create the Docker Swarm Configuration to Deploy ${{ env.TAG }}
        if: github.event_name == 'workflow_dispatch' || needs.build.result == 'success'
        env:
          ENV: ${{ env.ENVIRONMENT }}
          IMAGE_TAG: ${{ env.TAG }}
          REPLICAS: ${{ vars.REPLICAS || 1 }}
        run: |
          # append the tag to form a fully qualified Docker tag
          export IMAGE_TAG="${{ env.DOCKER_REPO }}:${IMAGE_TAG}"

          # do the env substitution and fix any issues with single quotes (more details in the Rails API)
          mv ${SWARM_YAML} ${SWARM_YAML}.orig && envsubst < ${SWARM_YAML}.orig > ${SWARM_YAML}

      - name: Timestamp the Docker Swarm Configuration
        if: github.event_name == 'workflow_dispatch' || needs.build.result == 'success'
        uses: ./.github/actions/stamp-swarm-config
        with:
          file: ${SWARM_YAML}

      - name: Copy Docker Swarm Configuration to S3 & Recycle Containers ‚ôªÔ∏è
        if: github.event_name == 'workflow_dispatch' || ( needs.build.result == 'success' && needs.build.result == 'success' )
        uses: ./.github/actions/update-docker-swarm-aws
        timeout-minutes: 2
        with:
          access_key_id: ${{ secrets.FE_AWS_ACCESS_KEY_ID }}
          bucket: "docker-swarm-${{ env.ENVIRONMENT }}"
          secret_access_key: ${{ secrets.FE_AWS_SECRET_ACCESS_KEY }} # TODO rename this variable
          yaml_file: ${{ env.SWARM_YAML }}